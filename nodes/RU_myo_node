#!/usr/bin/env python3
from __future__ import print_function

import argparse
import time
import math
import serial
from serial.tools.list_ports import comports

from geometry_msgs.msg import Quaternion, Vector3, PoseStamped, Point, Pose
from sensor_msgs.msg import Imu
from std_msgs.msg import Header, Float32MultiArray, Int16
import serial
from math import sqrt, degrees
from tf.transformations import euler_from_quaternion

import rospy
from connect_myo.common import *
from connect_myo.myo_lib import *
from geometry_msgs.msg import Quaternion, Vector3
from sensor_msgs.msg import Imu
from ros_myo.msg import MyoArm, EmgArray
from std_msgs.msg import String, UInt8, Header, MultiArrayLayout, MultiArrayDimension, Float64MultiArray



if __name__ == '__main__':
    # Start by initializing the Myo and attempting to connect. 
    # If no Myo is found, we attempt to reconnect every 0.5 seconds

    # parser = argparse.ArgumentParser()
    # parser.add_argument('serial_port', nargs='?', default=None)

    # parser.add_argument('-i', '--imu-topic', default='myo_imu')
    # parser.add_argument('-e', '--emg-topic', default='myo_emg')
    # parser.add_argument('-a', '--arm-topic', default='myo_arm')

    # args = parser.parse_args()
    
    # target = rospy.get_param('target_pos')
    serial_port = "/dev/ttyACM0"
    arm = "RU"
    addr = [252, 47, 132, 4, 235, 241]
    
    print('*****')
    print(serial_port)
    print("### RU ###")
    print("Initializing...")
    print()
    
    connected = 0
    while(connected == 0):
        try:
            m = MyoRaw(serial_port, arm, addr)
            connected = 1
        except (ValueError, KeyboardInterrupt) as e:
            print("Myo Armband not found. Attempting to connect...")
            rospy.sleep(0.5)
            pass

    # Define Publishers
    imuPub = rospy.Publisher('RU_myo/imu', Imu, queue_size=10)
    emgPub = rospy.Publisher('RU_myo/emg', EmgArray, queue_size=10)

    rospy.init_node('RU_myo_raw', anonymous=True)

    # Package the EMG data into an EmgArray
    def proc_emg(emg, moving, times=[]):
        ## create an array of ints for emg data
        emgPub.publish(emg)

        ## print framerate of received data
        times.append(time.time())
        if len(times) > 20:
            #print((len(times) - 1) / (times[-1] - times[0]))
            times.pop(0)
    # Package the IMU data into an Imu message
    def proc_imu(quat1, acc, gyro):
        # New info: https://github.com/thalmiclabs/myo-bluetooth/blob/master/myohw.h#L292-L295
        # Scale values for unpacking IMU data
        # define MYOHW_ORIENTATION_SCALE   16384.0f ///< See myohw_imu_data_t::orientation
        # define MYOHW_ACCELEROMETER_SCALE 2048.0f  ///< See myohw_imu_data_t::accelerometer
        # define MYOHW_GYROSCOPE_SCALE     16.0f    ///< See myohw_imu_data_t::gyroscope
        h = Header()
        h.stamp = rospy.Time.now()
        h.frame_id = 'RU_myo'
        # We currently do not know the covariance of the sensors with each other
        cov = [0, 0, 0, 0, 0, 0, 0, 0, 0]
        quat = Quaternion(quat1[0]/16384.0, quat1[1]/16384.0, quat1[2]/16384.0, quat1[3]/16384.0)
        ## Normalize the quaternion and accelerometer values
        quatNorm = math.sqrt(quat.x*quat.x+quat.y*quat.y+quat.z*quat.z+quat.w*quat.w)
        normQuat = Quaternion(quat.x/quatNorm, quat.y/quatNorm, quat.z/quatNorm, quat.w/quatNorm)
        normAcc = Vector3(acc[0]/2048.0, acc[1]/2048.0, acc[2]/2048.0)
        normGyro = Vector3(gyro[0]/16.0, gyro[1]/16.0, gyro[2]/16.0)
        imu = Imu(h, normQuat, cov, normGyro, cov, normAcc, cov)
        imuPub.publish(imu)

    m.add_emg_handler(proc_emg)
    m.add_imu_handler(proc_imu)


    m.connect()
    

    try:

        while not rospy.is_shutdown():
            m.run(1)

    except (rospy.ROSInterruptException, serial.serialutil.SerialException) as e:
        pass
    finally:
        print()
        print("Disconnecting...")
        m.disconnect()
        print()